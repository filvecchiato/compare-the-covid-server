import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.8.1
 * Query Engine version: 439da16b2f8314c6faca7d2dad2cdcf0732e8a9c
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'findFirst'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Events
 * const events = await prisma.events.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Events
   * const events = await prisma.events.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$queryRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): eventsDelegate;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): locationsDelegate;

  /**
   * `prisma.savedLocations`: Exposes CRUD operations for the **savedLocations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedLocations
    * const savedLocations = await prisma.savedLocations.findMany()
    * ```
    */
  get savedLocations(): savedLocationsDelegate;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): usersDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const EventsDistinctFieldEnum: {
  id: 'id',
  alertType: 'alertType',
  alertDate: 'alertDate',
  alertScore: 'alertScore',
  created_at: 'created_at',
  expires_on: 'expires_on'
};

export declare type EventsDistinctFieldEnum = (typeof EventsDistinctFieldEnum)[keyof typeof EventsDistinctFieldEnum]


export declare const LocationsDistinctFieldEnum: {
  id: 'id',
  location_events: 'location_events',
  name: 'name',
  country: 'country',
  googlemap_URL: 'googlemap_URL',
  location_type: 'location_type',
  longitude: 'longitude',
  latitutde: 'latitutde'
};

export declare type LocationsDistinctFieldEnum = (typeof LocationsDistinctFieldEnum)[keyof typeof LocationsDistinctFieldEnum]


export declare const SavedLocationsDistinctFieldEnum: {
  id: 'id',
  user_id: 'user_id',
  location_id: 'location_id'
};

export declare type SavedLocationsDistinctFieldEnum = (typeof SavedLocationsDistinctFieldEnum)[keyof typeof SavedLocationsDistinctFieldEnum]


export declare const UsersDistinctFieldEnum: {
  id: 'id',
  username: 'username',
  password: 'password',
  email: 'email'
};

export declare type UsersDistinctFieldEnum = (typeof UsersDistinctFieldEnum)[keyof typeof UsersDistinctFieldEnum]


export declare const alert_type: {
  confirmed: 'confirmed',
  safe: 'safe',
  suspected: 'suspected'
};

export declare type alert_type = (typeof alert_type)[keyof typeof alert_type]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export declare const QueryMode: {
  default: 'default',
  insensitive: 'insensitive'
};

export declare type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]



/**
 * Model events
 */

export type events = {
  id: number
  alertType: alert_type | null
  alertDate: Date | null
  alertScore: number | null
  created_at: Date | null
  expires_on: Date | null
}


export type AggregateEvents = {
  count: number
  avg: EventsAvgAggregateOutputType | null
  sum: EventsSumAggregateOutputType | null
  min: EventsMinAggregateOutputType | null
  max: EventsMaxAggregateOutputType | null
}

export type EventsAvgAggregateOutputType = {
  id: number
  alertScore: number | null
}

export type EventsSumAggregateOutputType = {
  id: number
  alertScore: number | null
}

export type EventsMinAggregateOutputType = {
  id: number
  alertScore: number | null
}

export type EventsMaxAggregateOutputType = {
  id: number
  alertScore: number | null
}


export type EventsAvgAggregateInputType = {
  id?: true
  alertScore?: true
}

export type EventsSumAggregateInputType = {
  id?: true
  alertScore?: true
}

export type EventsMinAggregateInputType = {
  id?: true
  alertScore?: true
}

export type EventsMaxAggregateInputType = {
  id?: true
  alertScore?: true
}

export type AggregateEventsArgs = {
  where?: eventsWhereInput
  orderBy?: Enumerable<eventsOrderByInput> | eventsOrderByInput
  cursor?: eventsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EventsDistinctFieldEnum>
  count?: true
  avg?: EventsAvgAggregateInputType
  sum?: EventsSumAggregateInputType
  min?: EventsMinAggregateInputType
  max?: EventsMaxAggregateInputType
}

export type GetEventsAggregateType<T extends AggregateEventsArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetEventsAggregateScalarType<T[P]>
}

export type GetEventsAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof EventsAvgAggregateOutputType ? EventsAvgAggregateOutputType[P] : never
}
    
    

export type eventsSelect = {
  id?: boolean
  alertType?: boolean
  alertDate?: boolean
  alertScore?: boolean
  created_at?: boolean
  expires_on?: boolean
  locations?: boolean | FindManylocationsArgs
}

export type eventsInclude = {
  locations?: boolean | FindManylocationsArgs
}

export type eventsGetPayload<
  S extends boolean | null | undefined | eventsArgs,
  U = keyof S
> = S extends true
  ? events
  : S extends undefined
  ? never
  : S extends eventsArgs | FindManyeventsArgs
  ? 'include' extends U
    ? events  & {
      [P in TrueKeys<S['include']>]:
      P extends 'locations'
      ? Array<locationsGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof events ? events[P]
: 
      P extends 'locations'
      ? Array<locationsGetPayload<S['select'][P]>> : never
    }
  : events
: events


export interface eventsDelegate {
  /**
   * Find zero or one Events that matches the filter.
   * @param {FindOneeventsArgs} args - Arguments to find a Events
   * @example
   * // Get one Events
   * const events = await prisma.events.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneeventsArgs>(
    args: Subset<T, FindOneeventsArgs>
  ): CheckSelect<T, Prisma__eventsClient<events | null>, Prisma__eventsClient<eventsGetPayload<T> | null>>
  /**
   * Find the first Events that matches the filter.
   * @param {FindFirsteventsArgs} args - Arguments to find a Events
   * @example
   * // Get one Events
   * const events = await prisma.events.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirsteventsArgs>(
    args?: Subset<T, FindFirsteventsArgs>
  ): CheckSelect<T, Prisma__eventsClient<events | null>, Prisma__eventsClient<eventsGetPayload<T> | null>>
  /**
   * Find zero or more Events that matches the filter.
   * @param {FindManyeventsArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Events
   * const events = await prisma.events.findMany()
   * 
   * // Get first 10 Events
   * const events = await prisma.events.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyeventsArgs>(
    args?: Subset<T, FindManyeventsArgs>
  ): CheckSelect<T, Promise<Array<events>>, Promise<Array<eventsGetPayload<T>>>>
  /**
   * Create a Events.
   * @param {eventsCreateArgs} args - Arguments to create a Events.
   * @example
   * // Create one Events
   * const Events = await prisma.events.create({
   *   data: {
   *     // ... data to create a Events
   *   }
   * })
   * 
  **/
  create<T extends eventsCreateArgs>(
    args: Subset<T, eventsCreateArgs>
  ): CheckSelect<T, Prisma__eventsClient<events>, Prisma__eventsClient<eventsGetPayload<T>>>
  /**
   * Delete a Events.
   * @param {eventsDeleteArgs} args - Arguments to delete one Events.
   * @example
   * // Delete one Events
   * const Events = await prisma.events.delete({
   *   where: {
   *     // ... filter to delete one Events
   *   }
   * })
   * 
  **/
  delete<T extends eventsDeleteArgs>(
    args: Subset<T, eventsDeleteArgs>
  ): CheckSelect<T, Prisma__eventsClient<events>, Prisma__eventsClient<eventsGetPayload<T>>>
  /**
   * Update one Events.
   * @param {eventsUpdateArgs} args - Arguments to update one Events.
   * @example
   * // Update one Events
   * const events = await prisma.events.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends eventsUpdateArgs>(
    args: Subset<T, eventsUpdateArgs>
  ): CheckSelect<T, Prisma__eventsClient<events>, Prisma__eventsClient<eventsGetPayload<T>>>
  /**
   * Delete zero or more Events.
   * @param {eventsDeleteManyArgs} args - Arguments to filter Events to delete.
   * @example
   * // Delete a few Events
   * const { count } = await prisma.events.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends eventsDeleteManyArgs>(
    args: Subset<T, eventsDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Events.
   * @param {eventsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Events
   * const events = await prisma.events.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends eventsUpdateManyArgs>(
    args: Subset<T, eventsUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Events.
   * @param {eventsUpsertArgs} args - Arguments to update or create a Events.
   * @example
   * // Update or create a Events
   * const events = await prisma.events.upsert({
   *   create: {
   *     // ... data to create a Events
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Events we want to update
   *   }
   * })
  **/
  upsert<T extends eventsUpsertArgs>(
    args: Subset<T, eventsUpsertArgs>
  ): CheckSelect<T, Prisma__eventsClient<events>, Prisma__eventsClient<eventsGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyeventsArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateEventsArgs>(args: Subset<T, AggregateEventsArgs>): Promise<GetEventsAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for events.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__eventsClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  locations<T extends FindManylocationsArgs = {}>(args?: Subset<T, FindManylocationsArgs>): CheckSelect<T, Promise<Array<locations>>, Promise<Array<locationsGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * events findOne
 */
export type FindOneeventsArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
  /**
   * Filter, which events to fetch.
  **/
  where: eventsWhereUniqueInput
}


/**
 * events findFirst
 */
export type FindFirsteventsArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
  /**
   * Filter, which events to fetch.
  **/
  where?: eventsWhereInput
  orderBy?: Enumerable<eventsOrderByInput> | eventsOrderByInput
  cursor?: eventsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EventsDistinctFieldEnum>
}


/**
 * events findMany
 */
export type FindManyeventsArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
  /**
   * Filter, which events to fetch.
  **/
  where?: eventsWhereInput
  /**
   * Determine the order of the events to fetch.
  **/
  orderBy?: Enumerable<eventsOrderByInput> | eventsOrderByInput
  /**
   * Sets the position for listing events.
  **/
  cursor?: eventsWhereUniqueInput
  /**
   * The number of events to fetch. If negative number, it will take events before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` events.
  **/
  skip?: number
  distinct?: Enumerable<EventsDistinctFieldEnum>
}


/**
 * events create
 */
export type eventsCreateArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
  /**
   * The data needed to create a events.
  **/
  data: eventsCreateInput
}


/**
 * events update
 */
export type eventsUpdateArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
  /**
   * The data needed to update a events.
  **/
  data: eventsUpdateInput
  /**
   * Choose, which events to update.
  **/
  where: eventsWhereUniqueInput
}


/**
 * events updateMany
 */
export type eventsUpdateManyArgs = {
  data: eventsUpdateManyMutationInput
  where?: eventsWhereInput
}


/**
 * events upsert
 */
export type eventsUpsertArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
  /**
   * The filter to search for the events to update in case it exists.
  **/
  where: eventsWhereUniqueInput
  /**
   * In case the events found by the `where` argument doesn't exist, create a new events with this data.
  **/
  create: eventsCreateInput
  /**
   * In case the events was found with the provided `where` argument, update it with this data.
  **/
  update: eventsUpdateInput
}


/**
 * events delete
 */
export type eventsDeleteArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
  /**
   * Filter which events to delete.
  **/
  where: eventsWhereUniqueInput
}


/**
 * events deleteMany
 */
export type eventsDeleteManyArgs = {
  where?: eventsWhereInput
}


/**
 * events without action
 */
export type eventsArgs = {
  /**
   * Select specific fields to fetch from the events
  **/
  select?: eventsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: eventsInclude | null
}



/**
 * Model locations
 */

export type locations = {
  id: number
  location_events: number | null
  name: string | null
  country: string | null
  googlemap_URL: string | null
  location_type: string | null
  longitude: number | null
  latitutde: number | null
}


export type AggregateLocations = {
  count: number
  avg: LocationsAvgAggregateOutputType | null
  sum: LocationsSumAggregateOutputType | null
  min: LocationsMinAggregateOutputType | null
  max: LocationsMaxAggregateOutputType | null
}

export type LocationsAvgAggregateOutputType = {
  id: number
  location_events: number | null
  longitude: number | null
  latitutde: number | null
}

export type LocationsSumAggregateOutputType = {
  id: number
  location_events: number | null
  longitude: number | null
  latitutde: number | null
}

export type LocationsMinAggregateOutputType = {
  id: number
  location_events: number | null
  longitude: number | null
  latitutde: number | null
}

export type LocationsMaxAggregateOutputType = {
  id: number
  location_events: number | null
  longitude: number | null
  latitutde: number | null
}


export type LocationsAvgAggregateInputType = {
  id?: true
  location_events?: true
  longitude?: true
  latitutde?: true
}

export type LocationsSumAggregateInputType = {
  id?: true
  location_events?: true
  longitude?: true
  latitutde?: true
}

export type LocationsMinAggregateInputType = {
  id?: true
  location_events?: true
  longitude?: true
  latitutde?: true
}

export type LocationsMaxAggregateInputType = {
  id?: true
  location_events?: true
  longitude?: true
  latitutde?: true
}

export type AggregateLocationsArgs = {
  where?: locationsWhereInput
  orderBy?: Enumerable<locationsOrderByInput> | locationsOrderByInput
  cursor?: locationsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<LocationsDistinctFieldEnum>
  count?: true
  avg?: LocationsAvgAggregateInputType
  sum?: LocationsSumAggregateInputType
  min?: LocationsMinAggregateInputType
  max?: LocationsMaxAggregateInputType
}

export type GetLocationsAggregateType<T extends AggregateLocationsArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetLocationsAggregateScalarType<T[P]>
}

export type GetLocationsAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof LocationsAvgAggregateOutputType ? LocationsAvgAggregateOutputType[P] : never
}
    
    

export type locationsSelect = {
  id?: boolean
  location_events?: boolean
  name?: boolean
  country?: boolean
  googlemap_URL?: boolean
  location_type?: boolean
  longitude?: boolean
  latitutde?: boolean
  events?: boolean | eventsArgs
  savedLocations?: boolean | FindManysavedLocationsArgs
}

export type locationsInclude = {
  events?: boolean | eventsArgs
  savedLocations?: boolean | FindManysavedLocationsArgs
}

export type locationsGetPayload<
  S extends boolean | null | undefined | locationsArgs,
  U = keyof S
> = S extends true
  ? locations
  : S extends undefined
  ? never
  : S extends locationsArgs | FindManylocationsArgs
  ? 'include' extends U
    ? locations  & {
      [P in TrueKeys<S['include']>]:
      P extends 'events'
      ? eventsGetPayload<S['include'][P]> | null :
      P extends 'savedLocations'
      ? Array<savedLocationsGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof locations ? locations[P]
: 
      P extends 'events'
      ? eventsGetPayload<S['select'][P]> | null :
      P extends 'savedLocations'
      ? Array<savedLocationsGetPayload<S['select'][P]>> : never
    }
  : locations
: locations


export interface locationsDelegate {
  /**
   * Find zero or one Locations that matches the filter.
   * @param {FindOnelocationsArgs} args - Arguments to find a Locations
   * @example
   * // Get one Locations
   * const locations = await prisma.locations.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnelocationsArgs>(
    args: Subset<T, FindOnelocationsArgs>
  ): CheckSelect<T, Prisma__locationsClient<locations | null>, Prisma__locationsClient<locationsGetPayload<T> | null>>
  /**
   * Find the first Locations that matches the filter.
   * @param {FindFirstlocationsArgs} args - Arguments to find a Locations
   * @example
   * // Get one Locations
   * const locations = await prisma.locations.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstlocationsArgs>(
    args?: Subset<T, FindFirstlocationsArgs>
  ): CheckSelect<T, Prisma__locationsClient<locations | null>, Prisma__locationsClient<locationsGetPayload<T> | null>>
  /**
   * Find zero or more Locations that matches the filter.
   * @param {FindManylocationsArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Locations
   * const locations = await prisma.locations.findMany()
   * 
   * // Get first 10 Locations
   * const locations = await prisma.locations.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManylocationsArgs>(
    args?: Subset<T, FindManylocationsArgs>
  ): CheckSelect<T, Promise<Array<locations>>, Promise<Array<locationsGetPayload<T>>>>
  /**
   * Create a Locations.
   * @param {locationsCreateArgs} args - Arguments to create a Locations.
   * @example
   * // Create one Locations
   * const Locations = await prisma.locations.create({
   *   data: {
   *     // ... data to create a Locations
   *   }
   * })
   * 
  **/
  create<T extends locationsCreateArgs>(
    args: Subset<T, locationsCreateArgs>
  ): CheckSelect<T, Prisma__locationsClient<locations>, Prisma__locationsClient<locationsGetPayload<T>>>
  /**
   * Delete a Locations.
   * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
   * @example
   * // Delete one Locations
   * const Locations = await prisma.locations.delete({
   *   where: {
   *     // ... filter to delete one Locations
   *   }
   * })
   * 
  **/
  delete<T extends locationsDeleteArgs>(
    args: Subset<T, locationsDeleteArgs>
  ): CheckSelect<T, Prisma__locationsClient<locations>, Prisma__locationsClient<locationsGetPayload<T>>>
  /**
   * Update one Locations.
   * @param {locationsUpdateArgs} args - Arguments to update one Locations.
   * @example
   * // Update one Locations
   * const locations = await prisma.locations.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends locationsUpdateArgs>(
    args: Subset<T, locationsUpdateArgs>
  ): CheckSelect<T, Prisma__locationsClient<locations>, Prisma__locationsClient<locationsGetPayload<T>>>
  /**
   * Delete zero or more Locations.
   * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
   * @example
   * // Delete a few Locations
   * const { count } = await prisma.locations.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends locationsDeleteManyArgs>(
    args: Subset<T, locationsDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Locations.
   * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Locations
   * const locations = await prisma.locations.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends locationsUpdateManyArgs>(
    args: Subset<T, locationsUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Locations.
   * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
   * @example
   * // Update or create a Locations
   * const locations = await prisma.locations.upsert({
   *   create: {
   *     // ... data to create a Locations
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Locations we want to update
   *   }
   * })
  **/
  upsert<T extends locationsUpsertArgs>(
    args: Subset<T, locationsUpsertArgs>
  ): CheckSelect<T, Prisma__locationsClient<locations>, Prisma__locationsClient<locationsGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManylocationsArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateLocationsArgs>(args: Subset<T, AggregateLocationsArgs>): Promise<GetLocationsAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for locations.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__locationsClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  events<T extends eventsArgs = {}>(args?: Subset<T, eventsArgs>): CheckSelect<T, Prisma__eventsClient<events | null>, Prisma__eventsClient<eventsGetPayload<T> | null>>;

  savedLocations<T extends FindManysavedLocationsArgs = {}>(args?: Subset<T, FindManysavedLocationsArgs>): CheckSelect<T, Promise<Array<savedLocations>>, Promise<Array<savedLocationsGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * locations findOne
 */
export type FindOnelocationsArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
  /**
   * Filter, which locations to fetch.
  **/
  where: locationsWhereUniqueInput
}


/**
 * locations findFirst
 */
export type FindFirstlocationsArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
  /**
   * Filter, which locations to fetch.
  **/
  where?: locationsWhereInput
  orderBy?: Enumerable<locationsOrderByInput> | locationsOrderByInput
  cursor?: locationsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<LocationsDistinctFieldEnum>
}


/**
 * locations findMany
 */
export type FindManylocationsArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
  /**
   * Filter, which locations to fetch.
  **/
  where?: locationsWhereInput
  /**
   * Determine the order of the locations to fetch.
  **/
  orderBy?: Enumerable<locationsOrderByInput> | locationsOrderByInput
  /**
   * Sets the position for listing locations.
  **/
  cursor?: locationsWhereUniqueInput
  /**
   * The number of locations to fetch. If negative number, it will take locations before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` locations.
  **/
  skip?: number
  distinct?: Enumerable<LocationsDistinctFieldEnum>
}


/**
 * locations create
 */
export type locationsCreateArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
  /**
   * The data needed to create a locations.
  **/
  data: locationsCreateInput
}


/**
 * locations update
 */
export type locationsUpdateArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
  /**
   * The data needed to update a locations.
  **/
  data: locationsUpdateInput
  /**
   * Choose, which locations to update.
  **/
  where: locationsWhereUniqueInput
}


/**
 * locations updateMany
 */
export type locationsUpdateManyArgs = {
  data: locationsUpdateManyMutationInput
  where?: locationsWhereInput
}


/**
 * locations upsert
 */
export type locationsUpsertArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
  /**
   * The filter to search for the locations to update in case it exists.
  **/
  where: locationsWhereUniqueInput
  /**
   * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
  **/
  create: locationsCreateInput
  /**
   * In case the locations was found with the provided `where` argument, update it with this data.
  **/
  update: locationsUpdateInput
}


/**
 * locations delete
 */
export type locationsDeleteArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
  /**
   * Filter which locations to delete.
  **/
  where: locationsWhereUniqueInput
}


/**
 * locations deleteMany
 */
export type locationsDeleteManyArgs = {
  where?: locationsWhereInput
}


/**
 * locations without action
 */
export type locationsArgs = {
  /**
   * Select specific fields to fetch from the locations
  **/
  select?: locationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: locationsInclude | null
}



/**
 * Model savedLocations
 */

export type savedLocations = {
  id: number
  user_id: number | null
  location_id: number | null
}


export type AggregateSavedLocations = {
  count: number
  avg: SavedLocationsAvgAggregateOutputType | null
  sum: SavedLocationsSumAggregateOutputType | null
  min: SavedLocationsMinAggregateOutputType | null
  max: SavedLocationsMaxAggregateOutputType | null
}

export type SavedLocationsAvgAggregateOutputType = {
  id: number
  user_id: number | null
  location_id: number | null
}

export type SavedLocationsSumAggregateOutputType = {
  id: number
  user_id: number | null
  location_id: number | null
}

export type SavedLocationsMinAggregateOutputType = {
  id: number
  user_id: number | null
  location_id: number | null
}

export type SavedLocationsMaxAggregateOutputType = {
  id: number
  user_id: number | null
  location_id: number | null
}


export type SavedLocationsAvgAggregateInputType = {
  id?: true
  user_id?: true
  location_id?: true
}

export type SavedLocationsSumAggregateInputType = {
  id?: true
  user_id?: true
  location_id?: true
}

export type SavedLocationsMinAggregateInputType = {
  id?: true
  user_id?: true
  location_id?: true
}

export type SavedLocationsMaxAggregateInputType = {
  id?: true
  user_id?: true
  location_id?: true
}

export type AggregateSavedLocationsArgs = {
  where?: savedLocationsWhereInput
  orderBy?: Enumerable<savedLocationsOrderByInput> | savedLocationsOrderByInput
  cursor?: savedLocationsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SavedLocationsDistinctFieldEnum>
  count?: true
  avg?: SavedLocationsAvgAggregateInputType
  sum?: SavedLocationsSumAggregateInputType
  min?: SavedLocationsMinAggregateInputType
  max?: SavedLocationsMaxAggregateInputType
}

export type GetSavedLocationsAggregateType<T extends AggregateSavedLocationsArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetSavedLocationsAggregateScalarType<T[P]>
}

export type GetSavedLocationsAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof SavedLocationsAvgAggregateOutputType ? SavedLocationsAvgAggregateOutputType[P] : never
}
    
    

export type savedLocationsSelect = {
  id?: boolean
  user_id?: boolean
  location_id?: boolean
  locations?: boolean | locationsArgs
  users?: boolean | usersArgs
}

export type savedLocationsInclude = {
  locations?: boolean | locationsArgs
  users?: boolean | usersArgs
}

export type savedLocationsGetPayload<
  S extends boolean | null | undefined | savedLocationsArgs,
  U = keyof S
> = S extends true
  ? savedLocations
  : S extends undefined
  ? never
  : S extends savedLocationsArgs | FindManysavedLocationsArgs
  ? 'include' extends U
    ? savedLocations  & {
      [P in TrueKeys<S['include']>]:
      P extends 'locations'
      ? locationsGetPayload<S['include'][P]> | null :
      P extends 'users'
      ? usersGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof savedLocations ? savedLocations[P]
: 
      P extends 'locations'
      ? locationsGetPayload<S['select'][P]> | null :
      P extends 'users'
      ? usersGetPayload<S['select'][P]> | null : never
    }
  : savedLocations
: savedLocations


export interface savedLocationsDelegate {
  /**
   * Find zero or one SavedLocations that matches the filter.
   * @param {FindOnesavedLocationsArgs} args - Arguments to find a SavedLocations
   * @example
   * // Get one SavedLocations
   * const savedLocations = await prisma.savedLocations.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnesavedLocationsArgs>(
    args: Subset<T, FindOnesavedLocationsArgs>
  ): CheckSelect<T, Prisma__savedLocationsClient<savedLocations | null>, Prisma__savedLocationsClient<savedLocationsGetPayload<T> | null>>
  /**
   * Find the first SavedLocations that matches the filter.
   * @param {FindFirstsavedLocationsArgs} args - Arguments to find a SavedLocations
   * @example
   * // Get one SavedLocations
   * const savedLocations = await prisma.savedLocations.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstsavedLocationsArgs>(
    args?: Subset<T, FindFirstsavedLocationsArgs>
  ): CheckSelect<T, Prisma__savedLocationsClient<savedLocations | null>, Prisma__savedLocationsClient<savedLocationsGetPayload<T> | null>>
  /**
   * Find zero or more SavedLocations that matches the filter.
   * @param {FindManysavedLocationsArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all SavedLocations
   * const savedLocations = await prisma.savedLocations.findMany()
   * 
   * // Get first 10 SavedLocations
   * const savedLocations = await prisma.savedLocations.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const savedLocationsWithIdOnly = await prisma.savedLocations.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManysavedLocationsArgs>(
    args?: Subset<T, FindManysavedLocationsArgs>
  ): CheckSelect<T, Promise<Array<savedLocations>>, Promise<Array<savedLocationsGetPayload<T>>>>
  /**
   * Create a SavedLocations.
   * @param {savedLocationsCreateArgs} args - Arguments to create a SavedLocations.
   * @example
   * // Create one SavedLocations
   * const SavedLocations = await prisma.savedLocations.create({
   *   data: {
   *     // ... data to create a SavedLocations
   *   }
   * })
   * 
  **/
  create<T extends savedLocationsCreateArgs>(
    args: Subset<T, savedLocationsCreateArgs>
  ): CheckSelect<T, Prisma__savedLocationsClient<savedLocations>, Prisma__savedLocationsClient<savedLocationsGetPayload<T>>>
  /**
   * Delete a SavedLocations.
   * @param {savedLocationsDeleteArgs} args - Arguments to delete one SavedLocations.
   * @example
   * // Delete one SavedLocations
   * const SavedLocations = await prisma.savedLocations.delete({
   *   where: {
   *     // ... filter to delete one SavedLocations
   *   }
   * })
   * 
  **/
  delete<T extends savedLocationsDeleteArgs>(
    args: Subset<T, savedLocationsDeleteArgs>
  ): CheckSelect<T, Prisma__savedLocationsClient<savedLocations>, Prisma__savedLocationsClient<savedLocationsGetPayload<T>>>
  /**
   * Update one SavedLocations.
   * @param {savedLocationsUpdateArgs} args - Arguments to update one SavedLocations.
   * @example
   * // Update one SavedLocations
   * const savedLocations = await prisma.savedLocations.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends savedLocationsUpdateArgs>(
    args: Subset<T, savedLocationsUpdateArgs>
  ): CheckSelect<T, Prisma__savedLocationsClient<savedLocations>, Prisma__savedLocationsClient<savedLocationsGetPayload<T>>>
  /**
   * Delete zero or more SavedLocations.
   * @param {savedLocationsDeleteManyArgs} args - Arguments to filter SavedLocations to delete.
   * @example
   * // Delete a few SavedLocations
   * const { count } = await prisma.savedLocations.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends savedLocationsDeleteManyArgs>(
    args: Subset<T, savedLocationsDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more SavedLocations.
   * @param {savedLocationsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many SavedLocations
   * const savedLocations = await prisma.savedLocations.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends savedLocationsUpdateManyArgs>(
    args: Subset<T, savedLocationsUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one SavedLocations.
   * @param {savedLocationsUpsertArgs} args - Arguments to update or create a SavedLocations.
   * @example
   * // Update or create a SavedLocations
   * const savedLocations = await prisma.savedLocations.upsert({
   *   create: {
   *     // ... data to create a SavedLocations
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the SavedLocations we want to update
   *   }
   * })
  **/
  upsert<T extends savedLocationsUpsertArgs>(
    args: Subset<T, savedLocationsUpsertArgs>
  ): CheckSelect<T, Prisma__savedLocationsClient<savedLocations>, Prisma__savedLocationsClient<savedLocationsGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManysavedLocationsArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateSavedLocationsArgs>(args: Subset<T, AggregateSavedLocationsArgs>): Promise<GetSavedLocationsAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for savedLocations.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__savedLocationsClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  locations<T extends locationsArgs = {}>(args?: Subset<T, locationsArgs>): CheckSelect<T, Prisma__locationsClient<locations | null>, Prisma__locationsClient<locationsGetPayload<T> | null>>;

  users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * savedLocations findOne
 */
export type FindOnesavedLocationsArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
  /**
   * Filter, which savedLocations to fetch.
  **/
  where: savedLocationsWhereUniqueInput
}


/**
 * savedLocations findFirst
 */
export type FindFirstsavedLocationsArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
  /**
   * Filter, which savedLocations to fetch.
  **/
  where?: savedLocationsWhereInput
  orderBy?: Enumerable<savedLocationsOrderByInput> | savedLocationsOrderByInput
  cursor?: savedLocationsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SavedLocationsDistinctFieldEnum>
}


/**
 * savedLocations findMany
 */
export type FindManysavedLocationsArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
  /**
   * Filter, which savedLocations to fetch.
  **/
  where?: savedLocationsWhereInput
  /**
   * Determine the order of the savedLocations to fetch.
  **/
  orderBy?: Enumerable<savedLocationsOrderByInput> | savedLocationsOrderByInput
  /**
   * Sets the position for listing savedLocations.
  **/
  cursor?: savedLocationsWhereUniqueInput
  /**
   * The number of savedLocations to fetch. If negative number, it will take savedLocations before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` savedLocations.
  **/
  skip?: number
  distinct?: Enumerable<SavedLocationsDistinctFieldEnum>
}


/**
 * savedLocations create
 */
export type savedLocationsCreateArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
  /**
   * The data needed to create a savedLocations.
  **/
  data: savedLocationsCreateInput
}


/**
 * savedLocations update
 */
export type savedLocationsUpdateArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
  /**
   * The data needed to update a savedLocations.
  **/
  data: savedLocationsUpdateInput
  /**
   * Choose, which savedLocations to update.
  **/
  where: savedLocationsWhereUniqueInput
}


/**
 * savedLocations updateMany
 */
export type savedLocationsUpdateManyArgs = {
  data: savedLocationsUpdateManyMutationInput
  where?: savedLocationsWhereInput
}


/**
 * savedLocations upsert
 */
export type savedLocationsUpsertArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
  /**
   * The filter to search for the savedLocations to update in case it exists.
  **/
  where: savedLocationsWhereUniqueInput
  /**
   * In case the savedLocations found by the `where` argument doesn't exist, create a new savedLocations with this data.
  **/
  create: savedLocationsCreateInput
  /**
   * In case the savedLocations was found with the provided `where` argument, update it with this data.
  **/
  update: savedLocationsUpdateInput
}


/**
 * savedLocations delete
 */
export type savedLocationsDeleteArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
  /**
   * Filter which savedLocations to delete.
  **/
  where: savedLocationsWhereUniqueInput
}


/**
 * savedLocations deleteMany
 */
export type savedLocationsDeleteManyArgs = {
  where?: savedLocationsWhereInput
}


/**
 * savedLocations without action
 */
export type savedLocationsArgs = {
  /**
   * Select specific fields to fetch from the savedLocations
  **/
  select?: savedLocationsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: savedLocationsInclude | null
}



/**
 * Model users
 */

export type users = {
  id: number
  username: string | null
  password: string | null
  email: string | null
}


export type AggregateUsers = {
  count: number
  avg: UsersAvgAggregateOutputType | null
  sum: UsersSumAggregateOutputType | null
  min: UsersMinAggregateOutputType | null
  max: UsersMaxAggregateOutputType | null
}

export type UsersAvgAggregateOutputType = {
  id: number
}

export type UsersSumAggregateOutputType = {
  id: number
}

export type UsersMinAggregateOutputType = {
  id: number
}

export type UsersMaxAggregateOutputType = {
  id: number
}


export type UsersAvgAggregateInputType = {
  id?: true
}

export type UsersSumAggregateInputType = {
  id?: true
}

export type UsersMinAggregateInputType = {
  id?: true
}

export type UsersMaxAggregateInputType = {
  id?: true
}

export type AggregateUsersArgs = {
  where?: usersWhereInput
  orderBy?: Enumerable<usersOrderByInput> | usersOrderByInput
  cursor?: usersWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UsersDistinctFieldEnum>
  count?: true
  avg?: UsersAvgAggregateInputType
  sum?: UsersSumAggregateInputType
  min?: UsersMinAggregateInputType
  max?: UsersMaxAggregateInputType
}

export type GetUsersAggregateType<T extends AggregateUsersArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetUsersAggregateScalarType<T[P]>
}

export type GetUsersAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof UsersAvgAggregateOutputType ? UsersAvgAggregateOutputType[P] : never
}
    
    

export type usersSelect = {
  id?: boolean
  username?: boolean
  password?: boolean
  email?: boolean
  savedLocations?: boolean | FindManysavedLocationsArgs
}

export type usersInclude = {
  savedLocations?: boolean | FindManysavedLocationsArgs
}

export type usersGetPayload<
  S extends boolean | null | undefined | usersArgs,
  U = keyof S
> = S extends true
  ? users
  : S extends undefined
  ? never
  : S extends usersArgs | FindManyusersArgs
  ? 'include' extends U
    ? users  & {
      [P in TrueKeys<S['include']>]:
      P extends 'savedLocations'
      ? Array<savedLocationsGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof users ? users[P]
: 
      P extends 'savedLocations'
      ? Array<savedLocationsGetPayload<S['select'][P]>> : never
    }
  : users
: users


export interface usersDelegate {
  /**
   * Find zero or one Users that matches the filter.
   * @param {FindOneusersArgs} args - Arguments to find a Users
   * @example
   * // Get one Users
   * const users = await prisma.users.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneusersArgs>(
    args: Subset<T, FindOneusersArgs>
  ): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>
  /**
   * Find the first Users that matches the filter.
   * @param {FindFirstusersArgs} args - Arguments to find a Users
   * @example
   * // Get one Users
   * const users = await prisma.users.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstusersArgs>(
    args?: Subset<T, FindFirstusersArgs>
  ): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>
  /**
   * Find zero or more Users that matches the filter.
   * @param {FindManyusersArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.users.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.users.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyusersArgs>(
    args?: Subset<T, FindManyusersArgs>
  ): CheckSelect<T, Promise<Array<users>>, Promise<Array<usersGetPayload<T>>>>
  /**
   * Create a Users.
   * @param {usersCreateArgs} args - Arguments to create a Users.
   * @example
   * // Create one Users
   * const Users = await prisma.users.create({
   *   data: {
   *     // ... data to create a Users
   *   }
   * })
   * 
  **/
  create<T extends usersCreateArgs>(
    args: Subset<T, usersCreateArgs>
  ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>
  /**
   * Delete a Users.
   * @param {usersDeleteArgs} args - Arguments to delete one Users.
   * @example
   * // Delete one Users
   * const Users = await prisma.users.delete({
   *   where: {
   *     // ... filter to delete one Users
   *   }
   * })
   * 
  **/
  delete<T extends usersDeleteArgs>(
    args: Subset<T, usersDeleteArgs>
  ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>
  /**
   * Update one Users.
   * @param {usersUpdateArgs} args - Arguments to update one Users.
   * @example
   * // Update one Users
   * const users = await prisma.users.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends usersUpdateArgs>(
    args: Subset<T, usersUpdateArgs>
  ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>
  /**
   * Delete zero or more Users.
   * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.users.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends usersDeleteManyArgs>(
    args: Subset<T, usersDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Users.
   * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const users = await prisma.users.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends usersUpdateManyArgs>(
    args: Subset<T, usersUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Users.
   * @param {usersUpsertArgs} args - Arguments to update or create a Users.
   * @example
   * // Update or create a Users
   * const users = await prisma.users.upsert({
   *   create: {
   *     // ... data to create a Users
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Users we want to update
   *   }
   * })
  **/
  upsert<T extends usersUpsertArgs>(
    args: Subset<T, usersUpsertArgs>
  ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyusersArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateUsersArgs>(args: Subset<T, AggregateUsersArgs>): Promise<GetUsersAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for users.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__usersClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  savedLocations<T extends FindManysavedLocationsArgs = {}>(args?: Subset<T, FindManysavedLocationsArgs>): CheckSelect<T, Promise<Array<savedLocations>>, Promise<Array<savedLocationsGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * users findOne
 */
export type FindOneusersArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
  /**
   * Filter, which users to fetch.
  **/
  where: usersWhereUniqueInput
}


/**
 * users findFirst
 */
export type FindFirstusersArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
  /**
   * Filter, which users to fetch.
  **/
  where?: usersWhereInput
  orderBy?: Enumerable<usersOrderByInput> | usersOrderByInput
  cursor?: usersWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UsersDistinctFieldEnum>
}


/**
 * users findMany
 */
export type FindManyusersArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
  /**
   * Filter, which users to fetch.
  **/
  where?: usersWhereInput
  /**
   * Determine the order of the users to fetch.
  **/
  orderBy?: Enumerable<usersOrderByInput> | usersOrderByInput
  /**
   * Sets the position for listing users.
  **/
  cursor?: usersWhereUniqueInput
  /**
   * The number of users to fetch. If negative number, it will take users before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` users.
  **/
  skip?: number
  distinct?: Enumerable<UsersDistinctFieldEnum>
}


/**
 * users create
 */
export type usersCreateArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
  /**
   * The data needed to create a users.
  **/
  data: usersCreateInput
}


/**
 * users update
 */
export type usersUpdateArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
  /**
   * The data needed to update a users.
  **/
  data: usersUpdateInput
  /**
   * Choose, which users to update.
  **/
  where: usersWhereUniqueInput
}


/**
 * users updateMany
 */
export type usersUpdateManyArgs = {
  data: usersUpdateManyMutationInput
  where?: usersWhereInput
}


/**
 * users upsert
 */
export type usersUpsertArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
  /**
   * The filter to search for the users to update in case it exists.
  **/
  where: usersWhereUniqueInput
  /**
   * In case the users found by the `where` argument doesn't exist, create a new users with this data.
  **/
  create: usersCreateInput
  /**
   * In case the users was found with the provided `where` argument, update it with this data.
  **/
  update: usersUpdateInput
}


/**
 * users delete
 */
export type usersDeleteArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
  /**
   * Filter which users to delete.
  **/
  where: usersWhereUniqueInput
}


/**
 * users deleteMany
 */
export type usersDeleteManyArgs = {
  where?: usersWhereInput
}


/**
 * users without action
 */
export type usersArgs = {
  /**
   * Select specific fields to fetch from the users
  **/
  select?: usersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: usersInclude | null
}



/**
 * Deep Input Types
 */


export type eventsWhereInput = {
  AND?: eventsWhereInput | Enumerable<eventsWhereInput>
  OR?: eventsWhereInput | Enumerable<eventsWhereInput>
  NOT?: eventsWhereInput | Enumerable<eventsWhereInput>
  id?: IntFilter | number
  alertType?: Enumalert_typeNullableFilter | alert_type | null
  alertDate?: DateTimeNullableFilter | Date | string | null
  alertScore?: IntNullableFilter | number | null
  created_at?: DateTimeNullableFilter | Date | string | null
  expires_on?: DateTimeNullableFilter | Date | string | null
  locations?: LocationsListRelationFilter
}

export type eventsOrderByInput = {
  id?: SortOrder
  alertType?: SortOrder
  alertDate?: SortOrder
  alertScore?: SortOrder
  created_at?: SortOrder
  expires_on?: SortOrder
}

export type eventsWhereUniqueInput = {
  id?: number
}

export type locationsWhereInput = {
  AND?: locationsWhereInput | Enumerable<locationsWhereInput>
  OR?: locationsWhereInput | Enumerable<locationsWhereInput>
  NOT?: locationsWhereInput | Enumerable<locationsWhereInput>
  id?: IntFilter | number
  location_events?: IntNullableFilter | number | null
  name?: StringNullableFilter | string | null
  country?: StringNullableFilter | string | null
  googlemap_URL?: StringNullableFilter | string | null
  location_type?: StringNullableFilter | string | null
  longitude?: FloatNullableFilter | number | null
  latitutde?: FloatNullableFilter | number | null
  events?: EventsRelationFilter | eventsWhereInput | null
  savedLocations?: SavedLocationsListRelationFilter
}

export type locationsOrderByInput = {
  id?: SortOrder
  location_events?: SortOrder
  name?: SortOrder
  country?: SortOrder
  googlemap_URL?: SortOrder
  location_type?: SortOrder
  longitude?: SortOrder
  latitutde?: SortOrder
}

export type locationsWhereUniqueInput = {
  id?: number
}

export type savedLocationsWhereInput = {
  AND?: savedLocationsWhereInput | Enumerable<savedLocationsWhereInput>
  OR?: savedLocationsWhereInput | Enumerable<savedLocationsWhereInput>
  NOT?: savedLocationsWhereInput | Enumerable<savedLocationsWhereInput>
  id?: IntFilter | number
  user_id?: IntNullableFilter | number | null
  location_id?: IntNullableFilter | number | null
  locations?: LocationsRelationFilter | locationsWhereInput | null
  users?: UsersRelationFilter | usersWhereInput | null
}

export type savedLocationsOrderByInput = {
  id?: SortOrder
  user_id?: SortOrder
  location_id?: SortOrder
}

export type savedLocationsWhereUniqueInput = {
  id?: number
}

export type usersWhereInput = {
  AND?: usersWhereInput | Enumerable<usersWhereInput>
  OR?: usersWhereInput | Enumerable<usersWhereInput>
  NOT?: usersWhereInput | Enumerable<usersWhereInput>
  id?: IntFilter | number
  username?: StringNullableFilter | string | null
  password?: StringNullableFilter | string | null
  email?: StringNullableFilter | string | null
  savedLocations?: SavedLocationsListRelationFilter
}

export type usersOrderByInput = {
  id?: SortOrder
  username?: SortOrder
  password?: SortOrder
  email?: SortOrder
}

export type usersWhereUniqueInput = {
  id?: number
}

export type eventsCreateInput = {
  alertType?: alert_type | null
  alertDate?: Date | string | null
  alertScore?: number | null
  created_at?: Date | string | null
  expires_on?: Date | string | null
  locations?: locationsCreateManyWithoutEventsInput
}

export type eventsUpdateInput = {
  alertType?: alert_type | NullableEnumalert_typeFieldUpdateOperationsInput | null
  alertDate?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  alertScore?: number | NullableIntFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  expires_on?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  locations?: locationsUpdateManyWithoutEventsInput
}

export type eventsUpdateManyMutationInput = {
  alertType?: alert_type | NullableEnumalert_typeFieldUpdateOperationsInput | null
  alertDate?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  alertScore?: number | NullableIntFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  expires_on?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type locationsCreateInput = {
  name?: string | null
  country?: string | null
  googlemap_URL?: string | null
  location_type?: string | null
  longitude?: number | null
  latitutde?: number | null
  events?: eventsCreateOneWithoutLocationsInput
  savedLocations?: savedLocationsCreateManyWithoutLocationsInput
}

export type locationsUpdateInput = {
  name?: string | NullableStringFieldUpdateOperationsInput | null
  country?: string | NullableStringFieldUpdateOperationsInput | null
  googlemap_URL?: string | NullableStringFieldUpdateOperationsInput | null
  location_type?: string | NullableStringFieldUpdateOperationsInput | null
  longitude?: number | NullableFloatFieldUpdateOperationsInput | null
  latitutde?: number | NullableFloatFieldUpdateOperationsInput | null
  events?: eventsUpdateOneWithoutLocationsInput
  savedLocations?: savedLocationsUpdateManyWithoutLocationsInput
}

export type locationsUpdateManyMutationInput = {
  name?: string | NullableStringFieldUpdateOperationsInput | null
  country?: string | NullableStringFieldUpdateOperationsInput | null
  googlemap_URL?: string | NullableStringFieldUpdateOperationsInput | null
  location_type?: string | NullableStringFieldUpdateOperationsInput | null
  longitude?: number | NullableFloatFieldUpdateOperationsInput | null
  latitutde?: number | NullableFloatFieldUpdateOperationsInput | null
}

export type savedLocationsCreateInput = {
  locations?: locationsCreateOneWithoutSavedLocationsInput
  users?: usersCreateOneWithoutSavedLocationsInput
}

export type savedLocationsUpdateInput = {
  locations?: locationsUpdateOneWithoutSavedLocationsInput
  users?: usersUpdateOneWithoutSavedLocationsInput
}

export type savedLocationsUpdateManyMutationInput = {

}

export type usersCreateInput = {
  username?: string | null
  password?: string | null
  email?: string | null
  savedLocations?: savedLocationsCreateManyWithoutUsersInput
}

export type usersUpdateInput = {
  username?: string | NullableStringFieldUpdateOperationsInput | null
  password?: string | NullableStringFieldUpdateOperationsInput | null
  email?: string | NullableStringFieldUpdateOperationsInput | null
  savedLocations?: savedLocationsUpdateManyWithoutUsersInput
}

export type usersUpdateManyMutationInput = {
  username?: string | NullableStringFieldUpdateOperationsInput | null
  password?: string | NullableStringFieldUpdateOperationsInput | null
  email?: string | NullableStringFieldUpdateOperationsInput | null
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type Enumalert_typeNullableFilter = {
  equals?: alert_type | null
  in?: Enumerable<alert_type> | null
  notIn?: Enumerable<alert_type> | null
  not?: alert_type | NestedEnumalert_typeNullableFilter | null
}

export type DateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date> | Enumerable<string> | null
  notIn?: Enumerable<Date> | Enumerable<string> | null
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeNullableFilter | null
}

export type IntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type LocationsListRelationFilter = {
  every?: locationsWhereInput
  some?: locationsWhereInput
  none?: locationsWhereInput
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  mode?: QueryMode
  not?: string | NestedStringNullableFilter | null
}

export type FloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type EventsRelationFilter = {
  is?: eventsWhereInput | null
  isNot?: eventsWhereInput | null
}

export type SavedLocationsListRelationFilter = {
  every?: savedLocationsWhereInput
  some?: savedLocationsWhereInput
  none?: savedLocationsWhereInput
}

export type LocationsRelationFilter = {
  is?: locationsWhereInput | null
  isNot?: locationsWhereInput | null
}

export type UsersRelationFilter = {
  is?: usersWhereInput | null
  isNot?: usersWhereInput | null
}

export type locationsCreateManyWithoutEventsInput = {
  create?: locationsCreateWithoutEventsInput | Enumerable<locationsCreateWithoutEventsInput>
  connect?: locationsWhereUniqueInput | Enumerable<locationsWhereUniqueInput>
}

export type NullableEnumalert_typeFieldUpdateOperationsInput = {
  set?: alert_type | null
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
}

export type locationsUpdateManyWithoutEventsInput = {
  create?: locationsCreateWithoutEventsInput | Enumerable<locationsCreateWithoutEventsInput>
  connect?: locationsWhereUniqueInput | Enumerable<locationsWhereUniqueInput>
  set?: locationsWhereUniqueInput | Enumerable<locationsWhereUniqueInput>
  disconnect?: locationsWhereUniqueInput | Enumerable<locationsWhereUniqueInput>
  delete?: locationsWhereUniqueInput | Enumerable<locationsWhereUniqueInput>
  update?: locationsUpdateWithWhereUniqueWithoutEventsInput | Enumerable<locationsUpdateWithWhereUniqueWithoutEventsInput>
  updateMany?: locationsUpdateManyWithWhereNestedInput | Enumerable<locationsUpdateManyWithWhereNestedInput>
  deleteMany?: locationsScalarWhereInput | Enumerable<locationsScalarWhereInput>
  upsert?: locationsUpsertWithWhereUniqueWithoutEventsInput | Enumerable<locationsUpsertWithWhereUniqueWithoutEventsInput>
}

export type eventsCreateOneWithoutLocationsInput = {
  create?: eventsCreateWithoutLocationsInput
  connect?: eventsWhereUniqueInput
}

export type savedLocationsCreateManyWithoutLocationsInput = {
  create?: savedLocationsCreateWithoutLocationsInput | Enumerable<savedLocationsCreateWithoutLocationsInput>
  connect?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type NullableFloatFieldUpdateOperationsInput = {
  set?: number | null
}

export type eventsUpdateOneWithoutLocationsInput = {
  create?: eventsCreateWithoutLocationsInput
  connect?: eventsWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: eventsUpdateWithoutLocationsDataInput
  upsert?: eventsUpsertWithoutLocationsInput
}

export type savedLocationsUpdateManyWithoutLocationsInput = {
  create?: savedLocationsCreateWithoutLocationsInput | Enumerable<savedLocationsCreateWithoutLocationsInput>
  connect?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  set?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  disconnect?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  delete?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  update?: savedLocationsUpdateWithWhereUniqueWithoutLocationsInput | Enumerable<savedLocationsUpdateWithWhereUniqueWithoutLocationsInput>
  updateMany?: savedLocationsUpdateManyWithWhereNestedInput | Enumerable<savedLocationsUpdateManyWithWhereNestedInput>
  deleteMany?: savedLocationsScalarWhereInput | Enumerable<savedLocationsScalarWhereInput>
  upsert?: savedLocationsUpsertWithWhereUniqueWithoutLocationsInput | Enumerable<savedLocationsUpsertWithWhereUniqueWithoutLocationsInput>
}

export type locationsCreateOneWithoutSavedLocationsInput = {
  create?: locationsCreateWithoutSavedLocationsInput
  connect?: locationsWhereUniqueInput
}

export type usersCreateOneWithoutSavedLocationsInput = {
  create?: usersCreateWithoutSavedLocationsInput
  connect?: usersWhereUniqueInput
}

export type locationsUpdateOneWithoutSavedLocationsInput = {
  create?: locationsCreateWithoutSavedLocationsInput
  connect?: locationsWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: locationsUpdateWithoutSavedLocationsDataInput
  upsert?: locationsUpsertWithoutSavedLocationsInput
}

export type usersUpdateOneWithoutSavedLocationsInput = {
  create?: usersCreateWithoutSavedLocationsInput
  connect?: usersWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: usersUpdateWithoutSavedLocationsDataInput
  upsert?: usersUpsertWithoutSavedLocationsInput
}

export type savedLocationsCreateManyWithoutUsersInput = {
  create?: savedLocationsCreateWithoutUsersInput | Enumerable<savedLocationsCreateWithoutUsersInput>
  connect?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
}

export type savedLocationsUpdateManyWithoutUsersInput = {
  create?: savedLocationsCreateWithoutUsersInput | Enumerable<savedLocationsCreateWithoutUsersInput>
  connect?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  set?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  disconnect?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  delete?: savedLocationsWhereUniqueInput | Enumerable<savedLocationsWhereUniqueInput>
  update?: savedLocationsUpdateWithWhereUniqueWithoutUsersInput | Enumerable<savedLocationsUpdateWithWhereUniqueWithoutUsersInput>
  updateMany?: savedLocationsUpdateManyWithWhereNestedInput | Enumerable<savedLocationsUpdateManyWithWhereNestedInput>
  deleteMany?: savedLocationsScalarWhereInput | Enumerable<savedLocationsScalarWhereInput>
  upsert?: savedLocationsUpsertWithWhereUniqueWithoutUsersInput | Enumerable<savedLocationsUpsertWithWhereUniqueWithoutUsersInput>
}

export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type NestedEnumalert_typeNullableFilter = {
  equals?: alert_type | null
  in?: Enumerable<alert_type> | null
  notIn?: Enumerable<alert_type> | null
  not?: alert_type | NestedEnumalert_typeNullableFilter | null
}

export type NestedDateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date> | Enumerable<string> | null
  notIn?: Enumerable<Date> | Enumerable<string> | null
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeNullableFilter | null
}

export type NestedIntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringNullableFilter | null
}

export type NestedFloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type locationsCreateWithoutEventsInput = {
  name?: string | null
  country?: string | null
  googlemap_URL?: string | null
  location_type?: string | null
  longitude?: number | null
  latitutde?: number | null
  savedLocations?: savedLocationsCreateManyWithoutLocationsInput
}

export type locationsUpdateWithWhereUniqueWithoutEventsInput = {
  where: locationsWhereUniqueInput
  data: locationsUpdateWithoutEventsDataInput
}

export type locationsUpdateManyWithWhereNestedInput = {
  where: locationsScalarWhereInput
  data: locationsUpdateManyDataInput
}

export type locationsScalarWhereInput = {
  AND?: locationsScalarWhereInput | Enumerable<locationsScalarWhereInput>
  OR?: locationsScalarWhereInput | Enumerable<locationsScalarWhereInput>
  NOT?: locationsScalarWhereInput | Enumerable<locationsScalarWhereInput>
  id?: IntFilter | number
  location_events?: IntNullableFilter | number | null
  name?: StringNullableFilter | string | null
  country?: StringNullableFilter | string | null
  googlemap_URL?: StringNullableFilter | string | null
  location_type?: StringNullableFilter | string | null
  longitude?: FloatNullableFilter | number | null
  latitutde?: FloatNullableFilter | number | null
}

export type locationsUpsertWithWhereUniqueWithoutEventsInput = {
  where: locationsWhereUniqueInput
  update: locationsUpdateWithoutEventsDataInput
  create: locationsCreateWithoutEventsInput
}

export type eventsCreateWithoutLocationsInput = {
  alertType?: alert_type | null
  alertDate?: Date | string | null
  alertScore?: number | null
  created_at?: Date | string | null
  expires_on?: Date | string | null
}

export type savedLocationsCreateWithoutLocationsInput = {
  users?: usersCreateOneWithoutSavedLocationsInput
}

export type eventsUpdateWithoutLocationsDataInput = {
  alertType?: alert_type | NullableEnumalert_typeFieldUpdateOperationsInput | null
  alertDate?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  alertScore?: number | NullableIntFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  expires_on?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type eventsUpsertWithoutLocationsInput = {
  update: eventsUpdateWithoutLocationsDataInput
  create: eventsCreateWithoutLocationsInput
}

export type savedLocationsUpdateWithWhereUniqueWithoutLocationsInput = {
  where: savedLocationsWhereUniqueInput
  data: savedLocationsUpdateWithoutLocationsDataInput
}

export type savedLocationsUpdateManyWithWhereNestedInput = {
  where: savedLocationsScalarWhereInput
  data: savedLocationsUpdateManyDataInput
}

export type savedLocationsScalarWhereInput = {
  AND?: savedLocationsScalarWhereInput | Enumerable<savedLocationsScalarWhereInput>
  OR?: savedLocationsScalarWhereInput | Enumerable<savedLocationsScalarWhereInput>
  NOT?: savedLocationsScalarWhereInput | Enumerable<savedLocationsScalarWhereInput>
  id?: IntFilter | number
  user_id?: IntNullableFilter | number | null
  location_id?: IntNullableFilter | number | null
}

export type savedLocationsUpsertWithWhereUniqueWithoutLocationsInput = {
  where: savedLocationsWhereUniqueInput
  update: savedLocationsUpdateWithoutLocationsDataInput
  create: savedLocationsCreateWithoutLocationsInput
}

export type locationsCreateWithoutSavedLocationsInput = {
  name?: string | null
  country?: string | null
  googlemap_URL?: string | null
  location_type?: string | null
  longitude?: number | null
  latitutde?: number | null
  events?: eventsCreateOneWithoutLocationsInput
}

export type usersCreateWithoutSavedLocationsInput = {
  username?: string | null
  password?: string | null
  email?: string | null
}

export type locationsUpdateWithoutSavedLocationsDataInput = {
  name?: string | NullableStringFieldUpdateOperationsInput | null
  country?: string | NullableStringFieldUpdateOperationsInput | null
  googlemap_URL?: string | NullableStringFieldUpdateOperationsInput | null
  location_type?: string | NullableStringFieldUpdateOperationsInput | null
  longitude?: number | NullableFloatFieldUpdateOperationsInput | null
  latitutde?: number | NullableFloatFieldUpdateOperationsInput | null
  events?: eventsUpdateOneWithoutLocationsInput
}

export type locationsUpsertWithoutSavedLocationsInput = {
  update: locationsUpdateWithoutSavedLocationsDataInput
  create: locationsCreateWithoutSavedLocationsInput
}

export type usersUpdateWithoutSavedLocationsDataInput = {
  username?: string | NullableStringFieldUpdateOperationsInput | null
  password?: string | NullableStringFieldUpdateOperationsInput | null
  email?: string | NullableStringFieldUpdateOperationsInput | null
}

export type usersUpsertWithoutSavedLocationsInput = {
  update: usersUpdateWithoutSavedLocationsDataInput
  create: usersCreateWithoutSavedLocationsInput
}

export type savedLocationsCreateWithoutUsersInput = {
  locations?: locationsCreateOneWithoutSavedLocationsInput
}

export type savedLocationsUpdateWithWhereUniqueWithoutUsersInput = {
  where: savedLocationsWhereUniqueInput
  data: savedLocationsUpdateWithoutUsersDataInput
}

export type savedLocationsUpsertWithWhereUniqueWithoutUsersInput = {
  where: savedLocationsWhereUniqueInput
  update: savedLocationsUpdateWithoutUsersDataInput
  create: savedLocationsCreateWithoutUsersInput
}

export type locationsUpdateWithoutEventsDataInput = {
  name?: string | NullableStringFieldUpdateOperationsInput | null
  country?: string | NullableStringFieldUpdateOperationsInput | null
  googlemap_URL?: string | NullableStringFieldUpdateOperationsInput | null
  location_type?: string | NullableStringFieldUpdateOperationsInput | null
  longitude?: number | NullableFloatFieldUpdateOperationsInput | null
  latitutde?: number | NullableFloatFieldUpdateOperationsInput | null
  savedLocations?: savedLocationsUpdateManyWithoutLocationsInput
}

export type locationsUpdateManyDataInput = {
  name?: string | NullableStringFieldUpdateOperationsInput | null
  country?: string | NullableStringFieldUpdateOperationsInput | null
  googlemap_URL?: string | NullableStringFieldUpdateOperationsInput | null
  location_type?: string | NullableStringFieldUpdateOperationsInput | null
  longitude?: number | NullableFloatFieldUpdateOperationsInput | null
  latitutde?: number | NullableFloatFieldUpdateOperationsInput | null
}

export type savedLocationsUpdateWithoutLocationsDataInput = {
  users?: usersUpdateOneWithoutSavedLocationsInput
}

export type savedLocationsUpdateManyDataInput = {

}

export type savedLocationsUpdateWithoutUsersDataInput = {
  locations?: locationsUpdateOneWithoutSavedLocationsInput
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
